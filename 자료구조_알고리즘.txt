자료구조 - 데이터들을 저장/처리하는 구조 (책장)
알고리즘 - 문제를 해결하는 '방법' (책을 어떻게 꽂을 것인지)

자료구조 
[선형 구조]
1. stack
2. queue
3. linked list 
  1) singly linked list
  2) doubly linked list
[비선형 구조]
4. hash
5. tree
6. graph
-------------------------------------------
알고리즘
정렬 알고리즘
	- 합병 정렬
	- Quick 정렬
순회 알고리즘 
	- 너비우선탐색 (BFS)
	- 깊이우선탐색 (DFS)
-------------------------------------------
[ 시간복잡도와 공간복잡도 ]
시간복잡도(Time Complexity) 
 - 시간이 얼마나 걸리는지

공간복잡도(Space Complexity) 
 - 메모리를 얼마나 차지하는지
-------------------------------------------
n = 10;  // 데이터가 10개
sysout("hi"); 
for(int i = 0; i < n; ++i){
	for(int j = 0; j < n; ++j){
		sysout("ㅋㅋㅋ"); 
	}
}
for(int j = 0; j < n; ++j){
	sysout("ㅋㅋㅋ"); 
}
이 코드의 시간복잡도 f(n) = 1 + n^2 + n
-------------------------------------------
f(n) = 1 + n^2 + n --> O(n^2)
f(n) = 1	   --> O(1)
f(n) = 2	   --> O(1)
f(n) = 1 + 2n^3 + 53n --> O(n^3)

O(1) : 반복 X
O(N) : 단일 loop
O(N^2) : 이중 loop
O(N^3) : 삼중 loop
O(N^N) : N중 loop
O(logN) : 이분법을 사용한 loop
O(NlogN) : loop 안에 이분탐색 loop 

O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(N^3) < ...
-------------------------------------------
< Stack 구조 >
- 후입선출 구조 (Last In First Out, LIFO)
- 입력된 순의 역순으로 처리
- 텍스트 입력 커서, 인터넷 뒤로가기, RAM의 stack영역, CPU의 연산

  4 * (3 + 7) / 2 - 10
  CPU 연산은 후위표기법 사용 (역 polish 표기법)
  4 + 3 ---> 4 3 +


  4 * (3 + 7) / 2 - 10 --> 후기 표기법으로..
  4 * (3 7 +) / 2 - 10   
  4 (3 7 +) * / 2 - 10   
  4 (3 7 +) * / 2 - 10   
  4 (3 7 +) * 2 / - 10
  4 (3 7 +) * 2 / 10 -

  4 3 7 + * 2 / 10 -

+
7	*	/	-
3	10	2	10
4	4	40	20	10


< Queue 구조 >
- 선입선출 구조 (First In First Out, FIFO)

===============================================================================

단일연결리스트(Singly Linked List)

- 배열의 단점
	1) 개수 제한
	2) 중간에 새 원소를 추가하거나(삽입)
	   중간에 위치한 원소를 삭제할 때 .. -> 뒤의 원소들을 하나씩 땡김 혹은 밀어냄 : O(n)

선형구조 :
 배열, 연결리스트, Stack, Queue

 Stack 의 노드 추가 : O(1)

-------------------------------------------

< 비선형 구조 > -> 목적 : 검색 빠르게
해쉬구조 : Map 구조
트리구조 : 계층 구조
그래프구조 : 길찾기, 지하철 노선도


===============================================================================

트리(Tree)
- 계층적인 구조를 표현
- 트리는 노드(node)들과 노드들을 연결하는 링크(link)들로 구성됨
- 노드가 N개인 트리는 항상 N-1개의 링크(link)를 가진다
- 트리에서, 루트에서 어떤 노드로 가는 경로는 유일하다. 또한 임의의 두 노드 간의 경로도 유일하다 (같은 노드를 두 번 이상 방문하지 않는 다는 조건 하에)

용어
- 루트 노드(root node) : 부모가 없는 노드. 트리는 하나의 루트 노드만을 가진다.
- 단말 노드(leaf node) : 자식이 없는 노드이다.
- 내부(internal) 노드 : 리프 노드가 아닌 노드.
- 링크(link) : 노드를 연결하는 선 (edge, branch 라고도 부름).
- 형제(sibling) : 같은 부모를 가지는 노드.
- 조상 노드(Ancestors Node) : 임의의 노드에서 근 노드에 이르는 경로상에 있는 노드들
- 자손 노드(descendant node): 자식 노드를 포함해 계층적으로 현재 노드보다 하위에 존재하는 모든 노드
- 노드의 크기(size) : 자신을 포함한 모든 자손 노드의 개수.
- 노드의 깊이(depth) : 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수
- 노드의 레벨(level) : 트리의 특정 깊이를 가지는 노드의 집합
- 노드의 차수(degree) : 부(하위) 트리 갯수/간선수 (degree) = 각 노드가 지닌 가지의 수
- 트리의 차수(degree of tree) : 트리의 최대 차수
- 트리의 높이(height) : 루트 노드에서 가장 깊숙히 있는 노드의 깊이

-------------------------------------------

이진트리(Binary Tree)
- 이진 트리에서 각 노드는 최대 2개의 자식을 가진다.
- 각각의 자식 노드는 자신이 부모의 왼쪽 자식인지 오른쪽 자식인지가 지정된다. (자식이 한 명인 경우에도 적용)

이진 트리 종류
- 포화 이진 트리(full binary tree) : 모든 레벨에서 노드들이 모두 채워져 있는 트리
- 완전 이진트리(complete binary tree) :
    마지막 레벨을 제외하고 노드가 모두 채워져 있는 트리
    마지막 레벨도 다 채워져 있을 수도 있음
    마지막 레벨도 오른쪽으로 연속된 몇개의 노드만 비어있을 수 있음

이진트리 특징
- 높이가 h인 포화 이진 트리(full binary tree)는 2(h제곱) - 1개의 노드를 가진다
- 노드가 N개인 포화(full) 혹은 완전(complete) 이진 트리의 높이는 O(logN)이다.
- 노드가 N개인 이진트리의 높이는 최악의 경우 O(N)이 될 수 있다.

-------------------------------------------

비선형구조의 탐색(모든 노드 조회)
 - 너비우선탐색
 - 깊이우선탐색
	이진트리의 깊이우선탐색 : 전위순회(preorder), 중위순회(inorder), 후위순회(postorder)

-------------------------------------------

L - 왼쪽 자식 노드로 이동
D - 자기 자신
R - 오른쪽 자식 노드로 이동

전위순회 : D L R
중위순회 : L D R
후위순회 : L R D

-------------------------------------------

트리의 삭제
	1. 삭제할 노드를 찾는다.
	2. 삭제할 노드를 찾으면
		(1) target의 자식 노드가 0, 1개
		(2) target의 자식 노드가 2개
			target과 가장 근사한 값을 가진 노드(후계자 노드)를 찾는다.
				방법 1. target보다 작은 수 중 가장 큰 수를 찾는 방법.
				방법 2. target보다 큰 수 중 가장 작은 수를 찾는 방법.

===============================================================================