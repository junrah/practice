자료구조 - 데이터들을 저장/처리하는 구조 (책장)
알고리즘 - 문제를 해결하는 '방법' (책을 어떻게 꽂을 것인지)

자료구조 
[선형 구조]
1. stack
2. queue
3. linked list 
  1) singly linked list
  2) doubly linked list
[비선형 구조]
4. hash
5. tree
6. graph
-------------------------------------------
알고리즘
정렬 알고리즘
	- 합병 정렬
	- Quick 정렬
순회 알고리즘 
	- 너비우선탐색 (BFS)
	- 깊이우선탐색 (DFS)
-------------------------------------------
[ 시간복잡도와 공간복잡도 ]
시간복잡도(Time Complexity) 
 - 시간이 얼마나 걸리는지

공간복잡도(Space Complexity) 
 - 메모리를 얼마나 차지하는지
-------------------------------------------
n = 10;  // 데이터가 10개
sysout("hi"); 
for(int i = 0; i < n; ++i){
	for(int j = 0; j < n; ++j){
		sysout("ㅋㅋㅋ"); 
	}
}
for(int j = 0; j < n; ++j){
	sysout("ㅋㅋㅋ"); 
}
이 코드의 시간복잡도 f(n) = 1 + n^2 + n
-------------------------------------------
f(n) = 1 + n^2 + n --> O(n^2)
f(n) = 1	   --> O(1)
f(n) = 2	   --> O(1)
f(n) = 1 + 2n^3 + 53n --> O(n^3)

O(1) : 반복 X
O(N) : 단일 loop
O(N^2) : 이중 loop
O(N^3) : 삼중 loop
O(N^N) : N중 loop
O(logN) : 이분법을 사용한 loop
O(NlogN) : loop 안에 이분탐색 loop 

O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(N^3) < ...
-------------------------------------------
< Stack 구조 >
- 후입선출 구조 (Last In First Out, LIFO)
- 입력된 순의 역순으로 처리
- 텍스트 입력 커서, 인터넷 뒤로가기, RAM의 stack영역, CPU의 연산

  4 * (3 + 7) / 2 - 10
  CPU 연산은 후위표기법 사용 (역 polish 표기법)
  4 + 3 ---> 4 3 +


  4 * (3 + 7) / 2 - 10 --> 후기 표기법으로..
  4 * (3 7 +) / 2 - 10   
  4 (3 7 +) * / 2 - 10   
  4 (3 7 +) * / 2 - 10   
  4 (3 7 +) * 2 / - 10
  4 (3 7 +) * 2 / 10 -

  4 3 7 + * 2 / 10 -

+
7	*	/	-
3	10	2	10
4	4	40	20	10


< Queue 구조 >
- 선입선출 구조 (First In First Out, FIFO)

===============================================================================

단일연결리스트(Singly Linked List)

- 배열의 단점
	1) 개수 제한
	2) 중간에 새 원소를 추가하거나(삽입)
	   중간에 위치한 원소를 삭제할 때 .. -> 뒤의 원소들을 하나씩 땡김 혹은 밀어냄 : O(n)

선형구조 :
 배열, 연결리스트, Stack, Queue

 Stack 의 노드 추가 : O(1)

-------------------------------------------

< 비선형 구조 > -> 목적 : 검색 빠르게
해쉬구조 : Map 구조
트리구조 : 계층 구조
그래프구조 : 길찾기, 지하철 노선도


===============================================================================

트리(Tree)
- 계층적인 구조를 표현
- 트리는 노드(node)들과 노드들을 연결하는 링크(link)들로 구성됨
- 노드가 N개인 트리는 항상 N-1개의 링크(link)를 가진다
- 트리에서, 루트에서 어떤 노드로 가는 경로는 유일하다. 또한 임의의 두 노드 간의 경로도 유일하다 (같은 노드를 두 번 이상 방문하지 않는 다는 조건 하에)

용어
- 루트 노드(root node) : 부모가 없는 노드. 트리는 하나의 루트 노드만을 가진다.
- 단말 노드(leaf node) : 자식이 없는 노드이다.
- 내부(internal) 노드 : 리프 노드가 아닌 노드.
- 링크(link) : 노드를 연결하는 선 (edge, branch 라고도 부름).
- 형제(sibling) : 같은 부모를 가지는 노드.
- 조상 노드(Ancestors Node) : 임의의 노드에서 근 노드에 이르는 경로상에 있는 노드들
- 자손 노드(descendant node): 자식 노드를 포함해 계층적으로 현재 노드보다 하위에 존재하는 모든 노드
- 노드의 크기(size) : 자신을 포함한 모든 자손 노드의 개수.
- 노드의 깊이(depth) : 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수
- 노드의 레벨(level) : 트리의 특정 깊이를 가지는 노드의 집합
- 노드의 차수(degree) : 부(하위) 트리 갯수/간선수 (degree) = 각 노드가 지닌 가지의 수
- 트리의 차수(degree of tree) : 트리의 최대 차수
- 트리의 높이(height) : 루트 노드에서 가장 깊숙히 있는 노드의 깊이

-------------------------------------------

이진트리(Binary Tree)
- 이진 트리에서 각 노드는 최대 2개의 자식을 가진다.
- 각각의 자식 노드는 자신이 부모의 왼쪽 자식인지 오른쪽 자식인지가 지정된다. (자식이 한 명인 경우에도 적용)

이진 트리 종류
- 포화 이진 트리(full binary tree) : 모든 레벨에서 노드들이 모두 채워져 있는 트리
- 포화 이진 트리(Perfect Binary Tree) : 모든 단말 노드의 레벨이 동일하며, 최하위 자식 노드들이 모두 차 있음
- 완전 이진 트리(complete binary tree) :
    마지막 레벨을 제외하고 노드가 모두 채워져 있는 트리
    마지막 레벨도 다 채워져 있을 수도 있음
    마지막 레벨도 오른쪽으로 연속된 몇개의 노드만 비어있을 수 있음
    -> 마지막 레벨에서는, 노드가 꽉 차있지 않아도 되지만, 중간에 빈 곳이 있으면 안됨
    -> 여기서, 완전(complete)은 부모가 자식을 왼쪽부터 채운다는 말임
- 이진 힙(Binary Heap) :
    완전 이진 트리의 일종
    부모,자식 간에는 대소 관계가 있으나, 형제들 간에 대소 관계가 정해지지 않음. -> 부분 순서 트리(Partial Ordered Tree) 라고도 함
- 균형 트리(Balanced Tree) : 이진 트리에서 하위 노드 구조가 좌우 대칭이 되도록 한 것 (例, B-tree)

이진 트리의 표현

- 선형 자료구조인 일차원 배열 표현
    저장 공간 활용 비효율적, 부모 자식 노드 구분이 어려움, 프로그램 구현 용이
    완전이진트리에는 좋은 성능을 갖음
- 비선형 자료구조인 연결 리스트 표현 (보다 유용함)

이진트리 특징
- 높이가 h인 포화 이진 트리(full binary tree)는 2(h제곱) - 1개의 노드를 가진다
- 노드가 N개인 포화(full) 혹은 완전(complete) 이진 트리의 높이는 O(logN)이다.
- 노드가 N개인 이진트리의 높이는 최악의 경우 O(N)이 될 수 있다.

-------------------------------------------

비선형구조의 탐색(모든 노드 조회)
 - 너비우선탐색
 - 깊이우선탐색
	이진트리의 깊이우선탐색 : 전위순회(preorder), 중위순회(inorder), 후위순회(postorder)

-------------------------------------------

L - 왼쪽 자식 노드로 이동
D - 자기 자신
R - 오른쪽 자식 노드로 이동

전위순회 : D L R
중위순회 : L D R
후위순회 : L R D

-------------------------------------------

트리의 삭제
	1. 삭제할 노드를 찾는다.
	2. 삭제할 노드를 찾으면
		(1) target의 자식 노드가 0, 1개
		(2) target의 자식 노드가 2개
			target과 가장 근사한 값을 가진 노드(후계자 노드)를 찾는다.
				방법 1. target보다 작은 수 중 가장 큰 수를 찾는 방법.
				방법 2. target보다 큰 수 중 가장 작은 수를 찾는 방법.

===============================================================================

이진 트리의 응용

이진 검색 트리 (Binary Search Tree, BST)
 - 이진 트리 구조를 갖으나, 자료의 검색,삭제,삽입에 효율적이게 한 트리 자료구조
 - 각 노드는 2개의 자식 노드를 각각 가리키는 2개의 포인터를 갖음

AVL 트리 (AVL Tree, Adelson-Velskii and Landis's Tree)
 - 한 노드를 중심으로 좌우 부분의 트리 높이(height)의 차가 1 이하가 되도록 하는 이진 탐색 트리
 - 가장 초기에 나온 균형 잡힌(Balanced) 이진 탐색 트리

B 트리 (B-Tree, Balanced Tree)
 - 이진 탐색 트리를 보다 일반화시킨 트리 자료구조를 말함
 - 데이터베이스 및 파일시스템에 널리 쓰이는 자료구조

한편,
 - 이진 검색 트리 : 최대 2개의 자식 노드를 가질 수 있음
 - 다진 검색 트리 : 최대 3 이상의 자식 노드를 갖는 검색 트리 (k진 검색 트리)

-------------------------------------------

AVL 트리
1. 불균형 트리의 상황
  LL
  LR
  RR
  RL

2. 노드가 추가 될 때마다 균형인자(Balanced Factor)를 구한다.
 	BF : 서브트리 깊이의 차 (왼쪽 서브트리 - 오른쪽 서브트리) *순서상관없음

3. 균형인자의 절대값이 2를 넘으면 (1)의 4가지 상황 중 어떤 상황인지 판단한다.

4. 회전 실행

-------------------------------------------

그래프
- 정점과 간선으로 이루어진 자료구조
- 정점(Vertex)간의 관계를 표현하는 조직도
- 트리와는 달리 그래프는 정점마다 간선이 없을수도 있고 있을수도 있으며 루트 노드, 부모와 자식이라는 개념이 존재하지 않음
- 네트워크 모델 즉, 객체와 이에 대한 관계를 나타내는 유연한 방식
- 그래프를 순회하는 방식: DFS, BFS

용어
- 정점(vertice) : 노드(node)라고도 하며 정점에는 데이터가 저장됨
- 간선(edge): 링크(arcs)라고도 하며 노드간의 관계를 나타냄
- 인접 정점(adjacent vertex) : 간선에 의해 연결된 정점
- 단순 경로(simple-path): 경로 중 반복되는 정점이 없는것, 같은 간선을 자나가지 않는 경로
- 차수(degree): 무방향 그래프에서 하나의 정점에 인접한 정점의 수
- 진출 차수(out-degree) : 방향그래프에서 사용되는 용어로 한 노드에서 외부로 향하는 간선의 수를 뜻함
- 진입차수(in-degree) : 방향그래프에서 사용되는 용어로 외부 노드에서 들어오는 간선의 수를 뜻함

그래프 구현 방법
- 인접행렬 : 인접행렬은 그래프의 노드를 2차원 배열로 만든 것 -> 완성된 배열의 모양은 1, 2, 3, 4, 5, 6의 정점을 연결하는 노드에 다른 노드들이 인접 정점이라면 1, 아니면 0을 넣어준다
    장점 :
        2차원 배열 안에 모든 정점들의 간선 정보를 담기 때문에 배열의 위치를 확인하면 두 점에 대한 연결 정보를 조회할 때 O(1) 의 시간 복잡도면 가능함
        구현이 비교적 간편함
    단점 :
        모든 정점에 대해 간선 정보를 대입해야 하므로 O(n²) 의 시간복잡도가 소요된다
        무조건 2차원 배열이 필요하기에 필요 이상의 공간이 낭비된다
- 인접리스트 : 인접리스트란 그래프의 노드들을 리스트로 표현 -> 주로 정점의 리스트 배열을 만들어 관계를 설정해줌으로써 구현
    장점 :
        정점들의 연결 정보를 탐색할 때 O(n) 의 시간이면 가능함 (n: 간선의 갯수)
        필요한 만큼의 공간만 사용하기때문에 공간의 낭비가 적다
    단점:
        특정 두 점이 연결되었는지 확인하려면 인접행렬에 비해 시간이 오래 걸린다 (배열보다 search 속도느림)
        구현이 비교적 어렵다

그래프 탐색 : 첫 정점에서부터 그래프에 존재하는 모든 정점들을 모두 한번씩 방문하는 것을 그래프 탐색이라고 한다.
- 깊이 우선탐색(DFS) :
    깊이 우선탐색 DFS는 갈 수 있는 만큼 최대한 깊이 가고, 더 이상 갈 곳이 없다면 이전 정점으로 돌아가는 방식으로 그래프를 순회하는 방식 -> 간단히 재귀호출을 사용하여 구현하거나 스택을 사용하여 구현
- 넓이 우선탐색(BFS) :
    넓이 우선탐색 BFS는 시작정점을 방문한 후 시작 정점에 인접한 모든 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선방문하는 방법 -> 일반적으로 QUEUE를 사용해서 지금 위치에서 갈 수 있는 것들을 모두 큐에 넣는 방식으로 구현
