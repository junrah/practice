자료구조 - 데이터들을 저장/처리하는 구조 (책장)
알고리즘 - 문제를 해결하는 '방법' (책을 어떻게 꽂을 것인지)

자료구조 
[선형 구조]
1. stack
2. queue
3. linked list 
  1) singly linked list
  2) doubly linked list
[비선형 구조]
4. hash
5. tree
6. graph
---------------------------------------------
알고리즘
정렬 알고리즘
	- 합병 정렬
	- Quick 정렬
순회 알고리즘 
	- 너비우선탐색 (BFS)
	- 깊이우선탐색 (DFS)
---------------------------------------------
[ 시간복잡도와 공간복잡도 ]
시간복잡도(Time Complexity) 
 - 시간이 얼마나 걸리는지

공간복잡도(Space Complexity) 
 - 메모리를 얼마나 차지하는지
------------------------------------------
n = 10;  // 데이터가 10개
sysout("hi"); 
for(int i = 0; i < n; ++i){
	for(int j = 0; j < n; ++j){
		sysout("ㅋㅋㅋ"); 
	}
}
for(int j = 0; j < n; ++j){
	sysout("ㅋㅋㅋ"); 
}
이 코드의 시간복잡도 f(n) = 1 + n^2 + n
------------------------------------------
f(n) = 1 + n^2 + n --> O(n^2)
f(n) = 1	   --> O(1)
f(n) = 2	   --> O(1)
f(n) = 1 + 2n^3 + 53n --> O(n^3)

O(1) : 반복 X
O(N) : 단일 loop
O(N^2) : 이중 loop
O(N^3) : 삼중 loop
O(N^N) : N중 loop
O(logN) : 이분법을 사용한 loop
O(NlogN) : loop 안에 이분탐색 loop 

O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(N^3) < ...
------------------------------------------
< Stack 구조 >
- 후입선출 구조 (Last In First Out, LIFO)
- 입력된 순의 역순으로 처리
- 텍스트 입력 커서, 인터넷 뒤로가기, RAM의 stack영역, CPU의 연산

  4 * (3 + 7) / 2 - 10
  CPU 연산은 후위표기법 사용 (역 polish 표기법)
  4 + 3 ---> 4 3 +


  4 * (3 + 7) / 2 - 10 --> 후기 표기법으로..
  4 * (3 7 +) / 2 - 10   
  4 (3 7 +) * / 2 - 10   
  4 (3 7 +) * / 2 - 10   
  4 (3 7 +) * 2 / - 10
  4 (3 7 +) * 2 / 10 -

  4 3 7 + * 2 / 10 -

+
7	*	/	-
3	10	2	10
4	4	40	20	10


< Queue 구조 >
- 선입선출 구조 (First In First Out, FIFO)

---------------------------------------------------------------------------------

단일연결리스트(Singly Linked List)

- 배열의 단점
	1) 개수 제한
	2) 중간에 새 원소를 추가하거나(삽입)
	   중간에 위치한 원소를 삭제할 때 .. -> 뒤의 원소들을 하나씩 땡김 혹은 밀어냄 : O(n)

선형구조 :
 배열, 연결리스트, Stack, Queue

 Stack 의 노드 추가 : O(1)

-------------------------------------------

< 비선형 구조 > -> 목적 : 검색 빠르게
해쉬구조 : Map 구조
트리구조 : 계층 구조
그래프구조 : 길찾기, 지하철 노선도